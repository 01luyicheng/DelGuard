package installer

import (
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

// LinuxInstaller Linuxç³»ç»Ÿå®‰è£…å™¨
type LinuxInstaller struct {
	config *InstallConfig
}

// NewLinuxInstaller åˆ›å»ºLinuxå®‰è£…å™¨
func NewLinuxInstaller() *LinuxInstaller {
	return &LinuxInstaller{
		config: GetDefaultInstallConfig(),
	}
}

// Install åœ¨Linuxä¸Šå®‰è£…DelGuard
func (l *LinuxInstaller) Install() error {
	fmt.Println("ğŸ”§ å¼€å§‹åœ¨Linuxä¸Šå®‰è£…DelGuard...")

	// æ£€æŸ¥æƒé™
	if l.config.SystemWide && !IsRunningAsAdmin() {
		return fmt.Errorf("ç³»ç»Ÿçº§å®‰è£…éœ€è¦ç®¡ç†å‘˜æƒé™ï¼Œè¯·ä½¿ç”¨sudoè¿è¡Œ")
	}

	// åˆ›å»ºå®‰è£…ç›®å½•
	if err := os.MkdirAll(l.config.InstallPath, 0755); err != nil {
		return fmt.Errorf("åˆ›å»ºå®‰è£…ç›®å½•å¤±è´¥: %v", err)
	}

	if err := os.MkdirAll(l.config.BackupPath, 0755); err != nil {
		return fmt.Errorf("åˆ›å»ºå¤‡ä»½ç›®å½•å¤±è´¥: %v", err)
	}

	// è·å–å½“å‰å¯æ‰§è¡Œæ–‡ä»¶è·¯å¾„
	currentExe, err := os.Executable()
	if err != nil {
		return fmt.Errorf("è·å–å½“å‰å¯æ‰§è¡Œæ–‡ä»¶è·¯å¾„å¤±è´¥: %v", err)
	}

	// å¤åˆ¶DelGuardåˆ°å®‰è£…ç›®å½•
	targetExe := filepath.Join(l.config.InstallPath, "delguard")
	if err := l.copyFile(currentExe, targetExe); err != nil {
		return fmt.Errorf("å¤åˆ¶å¯æ‰§è¡Œæ–‡ä»¶å¤±è´¥: %v", err)
	}

	// è®¾ç½®å¯æ‰§è¡Œæƒé™
	if err := os.Chmod(targetExe, 0755); err != nil {
		return fmt.Errorf("è®¾ç½®å¯æ‰§è¡Œæƒé™å¤±è´¥: %v", err)
	}

	// åˆ›å»ºå‘½ä»¤åˆ«åè„šæœ¬
	if err := l.createCommandAliases(targetExe); err != nil {
		return fmt.Errorf("åˆ›å»ºå‘½ä»¤åˆ«åå¤±è´¥: %v", err)
	}

	// æ›´æ–°shellé…ç½®æ–‡ä»¶
	if err := l.updateShellConfig(); err != nil {
		fmt.Printf("âš ï¸ æ›´æ–°shellé…ç½®å¤±è´¥: %v\n", err)
		fmt.Println("   æ‚¨å¯èƒ½éœ€è¦æ‰‹åŠ¨é…ç½®shellåˆ«å")
	}

	fmt.Println("âœ… DelGuardå®‰è£…å®Œæˆï¼")
	fmt.Println("ğŸ“ å®‰è£…ä¿¡æ¯:")
	fmt.Printf("   å®‰è£…è·¯å¾„: %s\n", l.config.InstallPath)
	fmt.Printf("   å¤‡ä»½è·¯å¾„: %s\n", l.config.BackupPath)
	fmt.Println("ğŸ”„ è¯·é‡æ–°å¯åŠ¨ç»ˆç«¯æˆ–è¿è¡Œä»¥ä¸‹å‘½ä»¤åˆ·æ–°ç¯å¢ƒ:")
	fmt.Println("   source ~/.bashrc  # æˆ– source ~/.zshrc")

	return nil
}

// Uninstall å¸è½½DelGuard
func (l *LinuxInstaller) Uninstall() error {
	fmt.Println("ğŸ—‘ï¸ å¼€å§‹å¸è½½DelGuard...")

	// åˆ é™¤shellé…ç½®
	if err := l.removeShellConfig(); err != nil {
		fmt.Printf("âš ï¸ åˆ é™¤shellé…ç½®å¤±è´¥: %v\n", err)
	}

	// åˆ é™¤å®‰è£…ç›®å½•
	if err := os.RemoveAll(l.config.InstallPath); err != nil {
		return fmt.Errorf("åˆ é™¤å®‰è£…ç›®å½•å¤±è´¥: %v", err)
	}

	fmt.Println("âœ… DelGuardå¸è½½å®Œæˆï¼")
	fmt.Println("ğŸ”„ è¯·é‡æ–°å¯åŠ¨ç»ˆç«¯ä»¥å®Œå…¨æ¸…é™¤åˆ«å")

	return nil
}

// IsInstalled æ£€æŸ¥æ˜¯å¦å·²å®‰è£…
func (l *LinuxInstaller) IsInstalled() bool {
	targetExe := filepath.Join(l.config.InstallPath, "delguard")
	_, err := os.Stat(targetExe)
	return err == nil
}

// GetInstallPath è·å–å®‰è£…è·¯å¾„
func (l *LinuxInstaller) GetInstallPath() string {
	return l.config.InstallPath
}

// BackupOriginalCommands å¤‡ä»½åŸå§‹å‘½ä»¤
func (l *LinuxInstaller) BackupOriginalCommands() error {
	commands := GetTargetCommands()
	for _, cmd := range commands {
		if err := l.backupCommand(cmd); err != nil {
			return fmt.Errorf("å¤‡ä»½å‘½ä»¤ %s å¤±è´¥: %v", cmd, err)
		}
	}
	return nil
}

// RestoreOriginalCommands æ¢å¤åŸå§‹å‘½ä»¤
func (l *LinuxInstaller) RestoreOriginalCommands() error {
	commands := GetTargetCommands()
	for _, cmd := range commands {
		if err := l.restoreCommand(cmd); err != nil {
			return fmt.Errorf("æ¢å¤å‘½ä»¤ %s å¤±è´¥: %v", cmd, err)
		}
	}
	return nil
}

// createCommandAliases åˆ›å»ºå‘½ä»¤åˆ«åè„šæœ¬
func (l *LinuxInstaller) createCommandAliases(delguardPath string) error {
	// åˆ›å»ºrmè„šæœ¬
	rmScript := fmt.Sprintf(`#!/bin/bash
# DelGuard safe delete wrapper for 'rm' command
"%s" delete "$@"
`, delguardPath)

	rmPath := filepath.Join(l.config.InstallPath, "rm")
	if err := os.WriteFile(rmPath, []byte(rmScript), 0755); err != nil {
		return fmt.Errorf("åˆ›å»ºrmè„šæœ¬å¤±è´¥: %v", err)
	}

	// åˆ›å»ºrmdirè„šæœ¬
	rmdirScript := fmt.Sprintf(`#!/bin/bash
# DelGuard safe delete wrapper for 'rmdir' command
"%s" delete "$@" -r
`, delguardPath)

	rmdirPath := filepath.Join(l.config.InstallPath, "rmdir")
	if err := os.WriteFile(rmdirPath, []byte(rmdirScript), 0755); err != nil {
		return fmt.Errorf("åˆ›å»ºrmdirè„šæœ¬å¤±è´¥: %v", err)
	}

	return nil
}

// updateShellConfig æ›´æ–°shellé…ç½®æ–‡ä»¶
func (l *LinuxInstaller) updateShellConfig() error {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return err
	}

	// æ£€æµ‹å½“å‰shell
	shell := os.Getenv("SHELL")
	var configFiles []string

	if strings.Contains(shell, "zsh") {
		configFiles = []string{
			filepath.Join(homeDir, ".zshrc"),
			filepath.Join(homeDir, ".zprofile"),
		}
	} else {
		configFiles = []string{
			filepath.Join(homeDir, ".bashrc"),
			filepath.Join(homeDir, ".bash_profile"),
			filepath.Join(homeDir, ".profile"),
		}
	}

	// DelGuardé…ç½®å†…å®¹
	configContent := fmt.Sprintf(`
# DelGuard Safe Delete Tool Configuration
# Auto-generated by DelGuard installer

# Add DelGuard to PATH
export PATH="%s:$PATH"

# DelGuard aliases
alias rm='delguard delete'
alias rmdir='delguard delete -r'

echo "DelGuard aliases loaded successfully"
echo "Commands: del, rm, cp, copy, delguard"
echo "Use --help for detailed help"
`, l.config.InstallPath)

	// æ›´æ–°ç¬¬ä¸€ä¸ªå­˜åœ¨çš„é…ç½®æ–‡ä»¶
	for _, configFile := range configFiles {
		if err := l.updateConfigFile(configFile, configContent); err == nil {
			return nil
		}
	}

	// å¦‚æœæ²¡æœ‰é…ç½®æ–‡ä»¶å­˜åœ¨ï¼Œåˆ›å»ºé»˜è®¤çš„
	defaultConfig := configFiles[0]
	return l.updateConfigFile(defaultConfig, configContent)
}

// removeShellConfig åˆ é™¤shellé…ç½®
func (l *LinuxInstaller) removeShellConfig() error {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return err
	}

	configFiles := []string{
		filepath.Join(homeDir, ".zshrc"),
		filepath.Join(homeDir, ".zprofile"),
		filepath.Join(homeDir, ".bashrc"),
		filepath.Join(homeDir, ".bash_profile"),
		filepath.Join(homeDir, ".profile"),
	}

	for _, configFile := range configFiles {
		if err := l.removeConfigFromFile(configFile); err != nil {
			log.Printf("ç§»é™¤é…ç½®å¤±è´¥: %v", err)
		}
	}

	return nil
}

// updateConfigFile æ›´æ–°é…ç½®æ–‡ä»¶
func (l *LinuxInstaller) updateConfigFile(configFile, configContent string) error {
	// è¯»å–ç°æœ‰é…ç½®æ–‡ä»¶
	var existingContent string
	if content, err := os.ReadFile(configFile); err == nil {
		existingContent = string(content)
	}

	// æ£€æŸ¥æ˜¯å¦å·²ç»åŒ…å«DelGuardé…ç½®
	if strings.Contains(existingContent, "DelGuard Safe Delete Tool Configuration") {
		// æ›¿æ¢ç°æœ‰é…ç½®
		lines := strings.Split(existingContent, "\n")
		var newLines []string
		skipMode := false

		for _, line := range lines {
			if strings.Contains(line, "DelGuard Safe Delete Tool Configuration") {
				skipMode = true
				continue
			}
			if skipMode && strings.TrimSpace(line) == "" && len(newLines) > 0 && strings.TrimSpace(newLines[len(newLines)-1]) == "" {
				skipMode = false
			}
			if !skipMode {
				newLines = append(newLines, line)
			}
		}

		existingContent = strings.Join(newLines, "\n")
	}

	// å†™å…¥æ–°é…ç½®
	finalContent := existingContent + configContent
	return os.WriteFile(configFile, []byte(finalContent), 0644)
}

// removeConfigFromFile ä»æ–‡ä»¶ä¸­åˆ é™¤é…ç½®
func (l *LinuxInstaller) removeConfigFromFile(configFile string) error {
	content, err := os.ReadFile(configFile)
	if err != nil {
		return nil // æ–‡ä»¶ä¸å­˜åœ¨ï¼Œæ— éœ€åˆ é™¤
	}

	existingContent := string(content)

	// ç§»é™¤DelGuardé…ç½®
	if strings.Contains(existingContent, "DelGuard Safe Delete Tool Configuration") {
		lines := strings.Split(existingContent, "\n")
		var newLines []string
		skipMode := false

		for _, line := range lines {
			if strings.Contains(line, "DelGuard Safe Delete Tool Configuration") {
				skipMode = true
				continue
			}
			if skipMode && strings.TrimSpace(line) == "" && len(newLines) > 0 && strings.TrimSpace(newLines[len(newLines)-1]) == "" {
				skipMode = false
				continue
			}
			if !skipMode {
				newLines = append(newLines, line)
			}
		}

		finalContent := strings.Join(newLines, "\n")
		return os.WriteFile(configFile, []byte(finalContent), 0644)
	}

	return nil
}

// backupCommand å¤‡ä»½å‘½ä»¤
func (l *LinuxInstaller) backupCommand(cmdName string) error {
	// æŸ¥æ‰¾åŸå§‹å‘½ä»¤è·¯å¾„
	originalPath, err := exec.LookPath(cmdName)
	if err != nil {
		return fmt.Errorf("æ‰¾ä¸åˆ°å‘½ä»¤ %s", cmdName)
	}

	// åˆ›å»ºå¤‡ä»½
	backupPath := filepath.Join(l.config.BackupPath, cmdName+".original")
	return l.copyFile(originalPath, backupPath)
}

// restoreCommand æ¢å¤å‘½ä»¤
func (l *LinuxInstaller) restoreCommand(cmdName string) error {
	backupPath := filepath.Join(l.config.BackupPath, cmdName+".original")
	if _, err := os.Stat(backupPath); os.IsNotExist(err) {
		return nil // å¤‡ä»½ä¸å­˜åœ¨ï¼Œæ— éœ€æ¢å¤
	}

	// è¿™é‡Œå®é™…ä¸Šä¸éœ€è¦æ¢å¤ï¼Œå› ä¸ºæˆ‘ä»¬ä½¿ç”¨çš„æ˜¯åˆ«åè€Œä¸æ˜¯æ›¿æ¢åŸå§‹å‘½ä»¤
	return nil
}

// copyFile å¤åˆ¶æ–‡ä»¶
func (l *LinuxInstaller) copyFile(src, dst string) error {
	sourceFile, err := os.Open(src)
	if err != nil {
		return err
	}
	defer sourceFile.Close()

	destFile, err := os.Create(dst)
	if err != nil {
		return err
	}
	defer destFile.Close()

	_, err = destFile.ReadFrom(sourceFile)
	return err
}
